<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export4.dtd">
<en-export export-date="20230714T003701Z" application="Evernote" version="10.56.9">
  <note>
    <title>Application Program</title>
    <created>20230425T181228Z</created>
    <updated>20230425T185705Z</updated>
    <note-attributes>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><ul><li><div>Before SQL statement is executed it must be <b>prepared </b>by the DBMS</div></li><ul><li><div>What indices can be used?</div></li><li><div>In what order should tables be accessed?</div></li><li><div>What constraints should be checked?</div></li></ul><li><div>Decisions are based on schema, table sizes, etc.</div></li><li><div>Result is a<b> query execution plan</b></div></li><li><div>Preparation is a complex activity, usually done at run time, justified by the complexity of query processing</div></li><li><div>SQL statements can be incorporated into an application program in two different ways:</div></li><li><div><b>Statement Level Interface (SLI) : </b></div></li><ul><li><div>Application program is a mixture of host language statements and SQL statements and directives</div></li><li><div>SQL Constructs in an application take two forms:</div></li><ul><li><div>Standard SQL statements - <b>static </b>or <b>embedded</b>: </div></li><ul><li><div>Useful when SQL portion of program known at compile time</div></li></ul></ul></ul><li><div><b>Call Level Interface (CLI): </b></div></li><ul><li><div>Application program is written entirely in host language</div></li><li><div>SQL statements are values of string variables that are passed as arguments to host language (library) procedures</div></li><li><div>Application uses string variables as arguments of library routines that communicate with DBMS</div></li><ul><li><div>executeQuery ("SQL query statement")</div></li></ul></ul><li><div>JDBC - Java Database Connector</div></li><ul><li><div>call level interface for executing SQL in Java programs</div></li><li><div>SQL statement is constructed at run time as the value of a Java variable</div></li><li><div>JDBC passes SQL statements to the underlying DBMS.</div></li><li><div>Can be interfaced to any DBMS that has a JDBC driver</div></li></ul></ul><div><br/></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>import java.sql.*;</div><div>Class.forName(driver name);</div><div>Connection con = DriverManager.getConnection(Url,Id,Passwd);</div><div>    //Static method of class DriverManager; attempts to connect to DBMS</div><div>    //If successful, creates a connection object, con, for managing the connection</div><div><br/></div><div>Statement stat = con.createStatement();</div><div>    //Creates a statement object stat</div><div>    //Statements have executeQuery() method</div><div><br/></div><div>//---------------------------------------------------</div><div><br/></div><div>String query = "SELECT T.StudID FROM Transcript T" +</div><div>                "WHERE T.CrsCode = 'cse305'" + </div><div>                "AND T.Semester = 'S2000'";</div><div>ResultSet res = stat.executeQuery(query);</div><div><br/></div><div>    //creates a result set object, res</div><div>    //prepares and executes the query</div><div>    //stores the result set produced by execution in res (opening a cursor)</div><div>    //the query string can be constructed at run time (as above)</div><div>    //the input pararmenters are plugged in</div><div><br/></div><div>//----------------------------------------------------</div><div><br/></div><div>String query = "SELECT T.StudID FROM Transcript T" +</div><div>                "WHERE T.CrsCode = ? and T.Semester = ?";</div><div>PreparedStatement ps = con.prepareStatement(query);</div><div><br/></div><div>    // Prepares the statement</div><div>    // Creates a prepared statement obect, ps, containing the prepared statement</div><div>    // Placeholders (?) mark positions of in parameters special API is provided to plug in the actual values</div><div><br/></div><div>//-----------------------------------------------------</div><div><br/></div><div>String crs_code, semester;</div><div>........</div><div><br/></div><div>ps.setString(1,crs_code);    //set value for first in parameter</div><div>ps.setString(2,semester);    //set value of second in parameter</div><div><br/></div><div>ResultSet res = ps.executeQuery();</div><div>    //Creates a result set object res</div><div>    //Executes the query</div><div>    //Stores the result set produced by execution in res</div><div><br/></div><div>while (res.next()) {                //advacned the ursor</div><div>    j = res.getInt("StudId");       //fetch output int-value  -> or res.getString ...etc</div><div>        //...process output value</div><div>} </div><div><br/></div><div>//After finishing with the results set close the prepared statement</div><div>ps.close();</div><div>stat.close();</div><div><br/></div><div>//After finishing the database you should close the connection</div><div>con.close();</div></div><div><br/></div></en-note>      ]]>
    </content>
  </note>
  <note>
    <title>Wanted &amp; Unwanted Redundancies</title>
    <created>20230418T180953Z</created>
    <updated>20230509T181509Z</updated>
    <note-attributes>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div>Insert Anomaly  -</div><div>Update Anomaly - Forgot to update the second table because of unwanted redundancies</div><div>Delete Anomaly - </div><ul><li><div>How to identify redundancies, first when we create a table in the table in other words the baseline table</div></li><li><div>we have to check to see if they're normalized (optimal)</div></li><li><div>then we determine the keys</div></li><li><div>then we determine the functional redundancies in the table</div></li><li><div>we check for some, some are okay, some aren't so we have to get rid of them</div></li><li><div>when we put the table in the fourth normalization?</div></li></ul><div>First we discussed these when we were away</div><div>Second we discussed these when we were away</div><div><br/></div><div><b>First normalization:</b></div><div>Check if the table is relational model table</div><div>How do we do this?</div><div>Some conditions: Four of em</div><ol><li><div>All the values must be single values, no lists or arrays</div></li><li><div>All elements in a column must be of the same type ( i.e. same domain)</div></li><li><div>Each column has a unique name and the order of the columns is not significant</div></li><li><div>No two rows can be identical and the order of the rows is not significant</div></li></ol><div><b>Second normalization:</b></div><ul><li><div>Functional dependencies</div></li><li><div>Figure out the partial dependencies</div></li><li><div>Dependencies are on part of the key</div></li><li><div>Split the table into several table to reduce redundancy </div></li><li><div>One to one relations - single row key then the relationship type can merge these tables through their entity types?</div></li></ul><div><br/></div><div><b>Third normalization:</b></div><div> A relation is in the 3NF if it is in the 2NF and has no transitive dependencies.</div><div>Rate category     Hour Rate</div><div style="padding-left:40px;">A                        60</div><div style="padding-left:40px;">B                        50</div><div style="padding-left:40px;">C                        40</div><div style="padding-left:40px;">A                        60</div><div style="padding-left:40px;">B                        40</div><div style="padding-left:40px;"><br/></div><div>Since B is 50 and 40, it is not in 3NF</div><div>BCNF: </div><div>Every determinate is not a key</div><div><b>Fourth normalization:</b></div><div><b><span style="--en-markholder:true;"><br/></span></b></div><div><b><span style="--en-markholder:true;"><br/></span></b></div></en-note>      ]]>
    </content>
  </note>
</en-export>
